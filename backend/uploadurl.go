package coolmaze

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"math/rand"
	"net/http"
	"time"

	"golang.org/x/net/context"

	"google.golang.org/appengine"
	"google.golang.org/appengine/log"
	"google.golang.org/cloud/storage"
)

// This is for sending a file resource.
// The resource transits on Google Cloud Storage.
// This endpoint produces 2 short-lived signed urls:
// - 1 for uploading the resource (from mobile to GCS)
// - 1 for downloading the resource (from GCS to desktop browser)

func init() {
	http.HandleFunc("/new-gcs-urls", gcsUrlsHandler)

	// This is important for randomString below
	rand.Seed(time.Now().UnixNano())

	var err error
	pkey, err = ioutil.ReadFile(pemFile)
	if err != nil {
		c := context.Background()
		log.Errorf(c, "%v", err)
	}
}

const (
	// This GCS bucket is used for temporary storage between
	// source mobile and target desktop.
	bucket         = "cool-maze-transit"
	serviceAccount = "mobile-to-gcs@cool-maze.iam.gserviceaccount.com"
	// This (secret) file was generated by command
	//    openssl pkcs12 -in Cool-Maze-2e343b6677b7.p12 -passin pass:notasecret -out Mobile-to-GCS.pem -nodes
	pemFile = "Mobile-to-GCS.pem"
)

var pkey []byte

func gcsUrlsHandler(w http.ResponseWriter, r *http.Request) {
	c := appengine.NewContext(r)
	if r.Method != "POST" {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "Only POST method is accepted")
		return
	}
	// Warning: this contentType will be part of the crypted
	// signature, and the client will have to match it exactly
	contentType := r.FormValue("type")

	urlPut, urlGet, err := createUrls(c, contentType)
	if err != nil {
		log.Errorf(c, "%v", err)
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintln(w, `{"success": false}`)
		return
	}
	response := Response{
		"success": true,
		"urlPut":  urlPut,
		"urlGet":  urlGet,
	}
	fmt.Fprintln(w, response)
}

func createUrls(c context.Context, contentType string) (urlPut, urlGet string, err error) {
	objectName := randomString()
	log.Infof(c, "Creating urls for tmp object name %s with content-type [%s]", objectName, contentType)

	urlPut, err = storage.SignedURL(bucket, objectName, &storage.SignedURLOptions{
		GoogleAccessID: serviceAccount,
		PrivateKey:     pkey,
		Method:         "PUT",
		Expires:        time.Now().Add(10 * time.Minute),
		ContentType:    contentType,
	})
	if err != nil {
		return
	}

	urlGet, err = storage.SignedURL(bucket, objectName, &storage.SignedURLOptions{
		GoogleAccessID: serviceAccount,
		PrivateKey:     pkey,
		Method:         "GET",
		Expires:        time.Now().Add(11 * time.Minute),
	})

	return
}

// Response is a generic container suitable to be directly converted into a JSON HTTP response.
// See http://nesv.blogspot.fr/2012/09/super-easy-json-http-responses-in-go.html
type Response map[string]interface{}

func (r Response) String() (s string) {
	b, err := json.MarshalIndent(r, "", "  ")
	if err != nil {
		s = ""
		return
	}
	s = string(b)
	return
}

func randomString() string {
	x, y := rand.Intn(123456789), rand.Intn(123456789)
	return fmt.Sprintf("%x%x", x, y)
}
